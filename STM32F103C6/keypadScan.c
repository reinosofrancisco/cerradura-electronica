/* Main.c file generated by New Project wizard
 *
 * Created:   Tue Sep 7 2021
 * Processor: STM32F103C6
 * Compiler:  Keil for ARM
 */




#include <stm32f1xx.h>
#include <string.h>
#include <keypadScan.h>


//Definicion de variable global privada
static const uint8_t teclas[4][4]= {
	{'7','8','9','A'},
	{'4','5','6','B'},
	{'1','2','3','C'},
	{'*','0','#','D'},
};

//Prototipo para funcion privada 
static uint8_t getKeyPressed(uint8_t *key);




/*******************************************************
FUNCION PARA INICIALIZAR EL TECLADO MATRICIAL
********************************************************/
void KEYPAD_Init(){
	 KEYPAD_PORT = 0x33338888;    /* PA8-PA11 as Outputs (FILAS) && PA12-PA15 as Inputs (COLUMNAS)*/
}



/********************************************************
FUNCION PARA ESCANEAR UN TECLADO MATRICIAL Y DEVOLVER LA
TECLA PRESIONADA UNA SOLA VEZ. TIENE DOBLE VERIFICACION Y
MEMORIZA LA ULTIMA TECLA PRESIONADA
DEVUELVE:
0 -> NO HAY NUEVA TECLA PRESIONADA
1 -> HAY NUEVA TECLA PRESIONADA Y ES *pkey
********************************************************/
uint8_t KEYPAD_Scan (uint8_t *pkey)
{
	static uint8_t Old_key;
	static uint8_t Key, Last_valid_key=0xFF; 	// no hay tecla presionada
	if(!getKeyPressed(&Key)) { 				//getKeyPressed hace barrido del teclado
		Old_key=0xFF; 					// no hay tecla presionada
		Last_valid_key=0xFF;
		return 0;
	}
	if(Key==Old_key) { //2da verificación
		if(Key!=Last_valid_key){ //evita múltiple detección
			*pkey=Key;
			Last_valid_key = Key;
			return 1;
		}
	}
	Old_key=Key; //1era verificación
	return 0;
}

/********************************************************
///////////////////BARRIDO DE TECLADO////////////////
********************************************************/
static uint8_t getKeyPressed(uint8_t *key)
{
	const uint16_t aux[4]={0x00007FFF,0x0000BFFF,0x0000DFFF,0x0000EFFF}; //{F1,F2,F3,F4} -> aux[i] implica 0 en Fila i
	uint8_t i;
	
	//uint32_t temp =  KEYPAD_PIN_OUT;		//Guardo el estado anterior del PIN_OUT
	KEYPAD_PORT = 0x33338888;			/* PA8-PA11 as Outputs (FILAS) && PA12-PA15 as Inputs (COLUMNAS)*/
	KEYPAD_PIN_OUT |= 0x0000FF00;		//Pongo las filas como 1 antes de entrar al for, por si tienen un estado inconsistente.
										 //Al asignar abajo, no es necesario, pero es buena practica.
	//Barrido
	for(i=0;i<4;i++){
		KEYPAD_PIN_OUT = aux[i]; 				//va poniendo un cero en cada fila para poder leerla
	       
		if(~KEYPAD_PIN_IN & KEYPAD_PORT0){		//Leo la entrada correspondiente del Keypad y hago un AND bit a bit con el PIN que me interesa del puerto.
			//Si entra al IF, Existe un 1 logico en el PIN deseado
			*key=teclas[i][0];
			return 1;
		}
		if(~KEYPAD_PIN_IN & KEYPAD_PORT1){
			*key=teclas[i][1];
			return 1;
		}
		if(~KEYPAD_PIN_IN & KEYPAD_PORT2){
			*key=teclas[i][2];
			return 1;
		}
		if(~KEYPAD_PIN_IN & KEYPAD_PORT3){
			*key=teclas[i][3];
			return 1;
		}
	}

	return 0;
}
